package com.chinasoft.it.wecode.event;

/**
 * 领域对象事件观察者
 *
 * 基于事件的消息的应用架构
 * 优点：降低系统耦合，提高吞吐量，默认具备高并发系统 削峰 能力
 * 缺点：代码编辑量多一些，在没有好的基础设施的情况下定位问题麻烦些，可能需要更好的API设计文档（主要是事件流传和业务处理）
 *
 * 原则1：那么虽然事件的好处有一些，且很可能每个领域对象可能都需要建立通知相关内容，但是在同一个模块内，尽量做到高内聚，跨模块时才考虑低耦合
 *        代码间建议还是使用接口调用，跨模块时才使用事件模型，
 * 例如：电商系统中的订单取消/删除，假设取消订单时订单头和行需要同步修改，同时将取消的量往库存上累加，那么订单头和行的修改应该是基于接口的（因为在同一个模块中），增加库存应该是基于事件的（不在订单模块）
 *
 * 通过上面我们可以知道，领域对象的事件不只是领域对象本身的增删改查，可能还有定制化的事件，就如上面的例子中，也许我们不能只告诉库存说我的状态改了，或者删除了，那么是不是我说这个订单修改是因为要将库存扣减的事件
 *
 *
 * 原则2：模块内的事件只应该关心自己的动作事件，跟据上面例子，订单状态修改了，那么我只能触发订单的修改消息，而不能触发库存的修改消息，库存的修改应该是因为收听了订单状态修改而被动触发的
 *
 * 通常只用创建领域对象的增加，修改，删除，其他具备具体业务处理的事件
 *
 * 遗留的问题：
 * 如果这样，我怎么知道比如我修改了订单状态，针对这个修改产生的事件的消费是否都按我的计划（并行/有序/条件）执行的，所以说这就变成了基于事件的服务编排问题
 */
public interface DomainEventObserver {

    /**
     * 领域对象动作之前
     */
    void before();

    /**
     * 领域对象动作之后
     */
    void after();

    class EventContext {

        /**
         * 消息类型，可以是标准消息例如CREATE,UPDATE,DELETE,也可以是业务自定义消息
         *
         */
        private String type;

        /**
         * 消息参数
         */
        private Object[] parameter;
    }
}
